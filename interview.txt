
1) inspect the text SQL in http://www.leafground.com/pages/checkbox.html

(//input[@type="checkbox"]/following-sibling::text())[3]


2) How to run a testcase in headless mode?

val chromeOptions = new ChromeOptions
chromeOptions.addArguments("--headless")
new ChromeDriver(chromeOptions)

EdgeOptions options = new EdgeOptions();
options.addArguments("--headless=new");
options.addArguments("--disable-gpu");

FirefoxOptions options = new FirefoxOptions();
options.setHeadless(true);

ChromeOptions options = new ChromeOptions();  
options.setHeadless(true); //Set Chrome option
driver = new ChromeDriver(options);  

3) How to send values in selenium without using sendkeys?

JavascriptExecutor JS = (JavascriptExecutor)webdriver;
JS.executeScript("document.getElementById('Pass').value='tester'");


   WebElement name= driver.findElement(By.xpath("your xpath");
    JavascriptExecutor js = (JavascriptExecutor) driver;
  js.executeAsyncScript("arguments[0].value='admin'",name); 

4) How do you upload a file using Selenium WebDriver?
To upload a file we can simply use the command element.send_keys(file path). But there is a prerequisite before 
we upload the file. We have to use the html tag: ‘input’ and attribute type should be ‘file’. 

5) What is Selenium server default port number?
 	
Selenium server default port number is 4444.

6)What is an Object Repository in Selenium?
An object repository is a centralized storage of locators in the form of objects. QAs store all the element locators in a separate file, also referred to as a property file (.properties) in Selenium. The property file stores information in a key-value pair format. This file serves as an object repository in Selenium WebDriver. 


7)All selenium exceptions are runtime exceptions or compile exception?
	Runtime exceptions

8)Is webdriver is an interface or class?

SearchContext is the super most interface in selenium, which is extended by another interface called WebDriver.
All the abstract methods of SearchContext and WebDriver interfaces are implemented in RemoteWebDriver class.
All the browser related classes such as FirefoxDriver, ChromeDriver etc., extends the RemoteWebdriver class.

9)How can you convert a String to an int in Java?
Integer.parseInt("12",16); 
Integer.valueOf("12",16);

10)Difference between Action and Actions in Selenium

In Selenium WebDriver, Action and Actions are two different classes that deal with performing complex user interactions like mouse movements, drag-and-drop, clicking multiple elements, etc. Here’s an explanation of both:

1. Actions Class
The Actions class is used to build a series of complex actions like mouse and keyboard interactions. It provides methods to handle multiple user interactions such as double-click, right-click, drag-and-drop, and more. The Actions class is part of the org.openqa.selenium.interactions package.

Key Features of the Actions Class:
Allows building composite actions like a series of actions to be performed in sequence.
It provides methods for mouse actions (e.g., click(), doubleClick(), moveToElement()) and keyboard actions (e.g., sendKeys()).
Used to create an action chain that can be executed by calling perform() at the end of the action chain.
Common Methods in the Actions Class:
click()
doubleClick()
contextClick() (right-click)
dragAndDrop()
moveToElement()
sendKeys()

Actions actions = new Actions(driver);
actions.moveToElement(element).click().perform();


In Selenium WebDriver, Action and Actions are two different classes that deal with performing complex user interactions like mouse movements, drag-and-drop, clicking multiple elements, etc. Here’s an explanation of both:

1. Actions Class
The Actions class is used to build a series of complex actions like mouse and keyboard interactions. It provides methods to handle multiple user interactions such as double-click, right-click, drag-and-drop, and more. The Actions class is part of the org.openqa.selenium.interactions package.

Key Features of the Actions Class:
Allows building composite actions like a series of actions to be performed in sequence.
It provides methods for mouse actions (e.g., click(), doubleClick(), moveToElement()) and keyboard actions (e.g., sendKeys()).
Used to create an action chain that can be executed by calling perform() at the end of the action chain.
Common Methods in the Actions Class:
click()
doubleClick()
contextClick() (right-click)
dragAndDrop()
moveToElement()
sendKeys()
Example of Actions Class:
java
Copy code
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.interactions.Actions;

public class ActionsExample {
    public static void main(String[] args) {
        // Set up WebDriver
        System.setProperty("webdriver.chrome.driver", "path/to/chromedriver");
        WebDriver driver = new ChromeDriver();

        // Navigate to a webpage
        driver.get("https://example.com");

        // Locate an element
        WebElement element = driver.findElement(By.id("elementId"));

        // Create an instance of the Actions class
        Actions actions = new Actions(driver);

        // Perform a series of actions - move to the element and click it
        actions.moveToElement(element).click().perform();

        // Close the driver
        driver.quit();
    }
}
In the example above, we create an Actions object and use moveToElement() to hover over an element, followed by a click(), and then call perform() to execute the action sequence.

Action Interface
The Action interface represents a single user interaction, such as clicking, sending keys, or moving the mouse. When you build a chain of actions using the Actions class, you can create an Action object and then execute it using the perform() method.

Key Points about Action:
Action is an interface that represents one interaction action like click(), dragAndDrop(), etc.
You don’t create an Action directly. Instead, it is typically created as part of the Actions class’s build() method.
An Action is usually a single operation that you can execute, as opposed to multiple actions being chained together.

Actions actions = new Actions(driver);
Action action = actions.moveToElement(element).click().build();
Action.perform();

Core Selenium & Java
=====================
1. How does Selenium WebDriver internally interact with the browser, and how is it different from Selenium RC?
Selenium WebDriver directly communicates with the browser using native browser automation APIs, whereas Selenium RC worked by injecting JavaScript into the browser and required a separate server. WebDriver is faster, more reliable, supports modern browsers, and handles complex user interactions better. Selenium RC is now deprecated.

2. Explain the difference between findElement() and findElements() and how you handle NoSuchElementException in large test suites.
How do you handle dynamic elements and changing locators in a complex web application?
findElement() returns a single WebElement and throws NoSuchElementException if not found.
findElements() returns a list and does not throw an exception; it returns an empty list instead.
In large frameworks, I prefer findElements() for validations and wrap element access with explicit waits and proper exception handling to avoid failures.

3. Handling Dynamic Elements & Changing Locators
Answer:
I use:
Dynamic XPath/CSS with stable attributes
Relative locators
Explicit waits (ExpectedConditions)
JavaScript executor when required
Centralized locator management using Page Object Model
If locators change frequently, I collaborate with developers to add automation-friendly attributes.

Wait Mechanisms & Synchronization
4. What are the limitations of Selenium, and how have you handled them in real projects?
Selenium cannot handle:
Captchas
Desktop applications
Performance testing
Image-based validation
To overcome this, I integrate Selenium with tools like TestNG, REST Assured, AutoIT, Sikuli, or use API testing and manual verification where needed.

5. Explain implicit wait, explicit wait, and fluent wait. In which scenarios would you avoid implicit waits?
Implicit wait: Global wait, not recommended for dynamic apps
Explicit wait: Condition-based, preferred
Fluent wait: Polling with exception handling
I avoid implicit waits because they conflict with explicit waits and increase execution time unpredictably.

6. How do you design a reliable wait strategy for highly dynamic applications (AJAX-heavy)?
I rely on:
Explicit waits for element visibility/clickability
Waiting for JavaScript and AJAX calls to complete
Custom wait utilities
Avoiding hard-coded sleeps
This ensures stability in highly dynamic applications.

Framework Design & Architecture
7. Can you explain the framework you designed or worked on (Hybrid / POM / BDD)? What were your design decisions?
I have worked on Hybrid frameworks combining POM, TestNG, and utility layers.
Page classes for UI actions
Test classes for validation
Utility classes for waits, reporting, logging
This structure improves reusability, readability, and maintenance.

8. How do you ensure your automation framework is scalable and maintainable for long-term projects?
I ensure scalability by:
Modular design
Reusable components
Config-driven execution
Environment separation
Parallel execution support
Code reviews and documentation

9. How do you manage test data and configuration across multiple environments?
I manage test data using:
JSON/Excel/CSV files
Database queries
Property files for environment configs
Sensitive data is handled using encryption or CI secrets.

Advanced Selenium Concepts
==========================
10. How do you handle multiple windows, iframes, and shadow DOM elements?
What approaches do you use for file upload/download validation in Selenium?
Windows: getWindowHandles()
Iframes: switchTo().frame()
Shadow DOM: JavaScriptExecutor or Selenium 4 shadow APIs
I always switch back to the default context after actions.

11. What approaches do you use for file upload/download validation in Selenium?
Upload: sendKeys() with file path
Download: Browser preferences + file existence validation
For complex cases, I validate file name, size, and content.

TestNG / JUnit / Cucumber
=========================
12. How do you capture screenshots and logs for failed test cases in parallel execution?
I use thread-safe reporting tools like Extent Reports and capture screenshots on failure using listeners. Each test maintains its own execution context to avoid conflicts.

13. How do you control test execution order, grouping, and parallel execution in TestNG?
I use:
Groups for test categorization
XML for execution control
Parallel execution at class/method level
RetryAnalyzer for flaky tests

14. What challenges have you faced while implementing Cucumber, and how did you resolve them?
Common challenges include step duplication and slow execution.
I resolve this by:
Reusable step definitions
Proper tagging
Limiting UI scenarios and moving logic to APIs

15. How do you generate and customize test execution reports?
I generate reports using Extent Reports / Allure and customize them with screenshots, logs, environment details, and execution summaries.

CI/CD & DevOps Integration
==========================
16. How have you integrated Selenium tests with CI/CD tools like Jenkins or GitHub Actions?
I integrate Selenium with Jenkins by:
Running tests via Maven
Parameterizing builds
Publishing reports
Triggering tests on code commits

17. How do you decide which test cases should run in CI pipelines versus nightly runs?
CI runs include smoke and critical regression tests.
Nightly runs include full regression suites and cross-browser tests.

Performance, Stability & Debugging
===================================
18. How do you identify and fix flaky tests in a large automation suite?
I analyze:
Synchronization issues
Environment instability
Data dependency
I refactor waits, improve locators, and isolate flaky tests.

19. What metrics do you track to measure automation effectiveness?
I track:
Pass/fail trends
Automation coverage
Execution time
Defect leakage
Flakiness rate

20. Describe a critical automation failure you faced in production and how you resolved it.
I once faced mass failures due to a UI redesign. I quickly analyzed common failures, updated shared components, stabilized locators, and restored the pipeline within the same day.

Leadership & Ownership (Important for 8+ Years)
===============================================
21. How do you mentor junior automation testers and review their code?
I mentor by:
Code reviews
Pair programming
Framework walkthroughs
Best practice sessions

22. How do you handle situations where automation timelines conflict with release deadlines?
I prioritize critical scenarios, communicate risks clearly, and ensure at least smoke automation is stable before release.

23. What improvements have you personally introduced to automation in your previous project?
I introduced parallel execution, reduced execution time, improved reporting, and increased automation coverage significantly.

Scenario-Based (Very Important)
===================================
24. If 200 Selenium test cases suddenly start failing after a UI change, how would you approach the issue?
I identify common failures, fix shared locators or base methods first, validate locally, then push fixes to stabilize the suite quickly.

25. How would you design an automation strategy for a project with frequent UI changes?
I focus on:
Stable locators
Business-critical flows
API automation support
Minimum UI dependency
This reduces maintenance effort.






